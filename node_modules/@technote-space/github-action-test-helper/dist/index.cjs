'use strict';

var fs = require('fs');
var path = require('path');
var jsYaml = require('js-yaml');
var vitest = require('vitest');
var os = require('os');
var github = require('@actions/github');
var core = require('@actions/core');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var core__namespace = /*#__PURE__*/_interopNamespaceDefault(core);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getContext = (override) => Object.assign({
    payload: {
        action: '',
    },
    eventName: '',
    sha: '',
    ref: '',
    workflow: '',
    action: '',
    actor: '',
    issue: {
        owner: '',
        repo: '',
        number: 1,
    },
    repo: {
        owner: '',
        repo: '',
    },
    job: '',
    runNumber: 1,
    runId: 1,
    apiUrl: 'https://api.github.com',
    serverUrl: 'https://github.com',
    graphqlUrl: 'https://api.github.com/graphql',
}, override);
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const generateContext = (settings, override) => {
    const overrideObj = override || {};
    return getContext(Object.assign({}, {
        eventName: settings.event ? settings.event : '',
        ref: settings.ref ? settings.ref : '',
        sha: settings.sha ? settings.sha : '',
        action: settings.owner ? (settings.owner + '-generator') : '',
    }, overrideObj, {
        payload: Object.assign({
            action: settings.action ? settings.action : '',
        }, overrideObj['payload'] || {}),
        issue: Object.assign({
            owner: settings.owner ? settings.owner : '',
            repo: settings.repo ? settings.repo : '',
        }, overrideObj['issue'] || {}),
        repo: Object.assign({
            owner: settings.owner ? settings.owner : '',
            repo: settings.repo ? settings.repo : '',
        }, overrideObj['repo'] || {}),
    }));
};
const createResponse = (data, override = {}) => Object.assign({
    data,
    status: 0,
    url: 'https://example.com',
    headers: {
        date: '',
        'x-ratelimit-limit': '',
        'x-ratelimit-remaining': '',
        'x-ratelimit-reset': '',
        'x-Octokit-request-id': '',
        'x-Octokit-media-type': '',
        link: '',
        'last-modified': '',
        etag: '',
        status: '',
    },
    [Symbol.iterator]() {
        return {
            next() {
                return {
                    done: true,
                    value: true,
                };
            },
        };
    },
}, override);

const encodeContent = (content) => Buffer.from(content).toString('base64');
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getConfigFixture = (rootDir, fileName = 'config.yml') => ({
    type: 'file',
    encoding: 'base64',
    size: 5362,
    name: fileName,
    path: `.github/${fileName}`,
    content: encodeContent(fs.readFileSync(path.resolve(rootDir, fileName)).toString()),
    sha: '3d21ec53a331a6f037a91c368710b99387d012c1',
    url: 'https://api.github.com/repos/Codertocat/Hello-World/contents/.github/release-drafter.yml',
    'git_url': 'https://api.github.com/repos/Codertocat/Hello-World/git/blobs/3d21ec53a331a6f037a91c368710b99387d012c1',
    'html_url': 'https://github.com/Codertocat/Hello-World/blob/master/.github/release-drafter.yml',
    'download_url': 'https://raw.githubusercontent.com/Codertocat/Hello-World/master/.github/release-drafter.yml',
    _links: {
        git: 'https://api.github.com/repos/Codertocat/Hello-World/git/blobs/3d21ec53a331a6f037a91c368710b99387d012c1',
        self: 'https://api.github.com/repos/Codertocat/Hello-World/contents/.github/release-drafter.yml',
        html: 'https://github.com/Codertocat/Hello-World/blob/master/.github/release-drafter.yml',
    },
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const getApiFixture = (rootDir, name, ext = '.json') => {
    const content = fs.readFileSync(path.resolve(rootDir, `${name}${ext}`)).toString();
    switch (ext.toLowerCase()) {
        case '.json':
            return JSON.parse(content);
        case '.yml':
        case '.yaml':
            return jsYaml.load(content) || {};
        default:
            return { content };
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
const disableNetConnect = (nock) => {
    vitest.beforeEach(() => {
        nock.disableNetConnect();
    });
    vitest.afterEach(() => {
        nock.cleanAll();
        nock.enableNetConnect();
    });
};

var global$1 = global;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setActionEnv = (rootDir) => {
    const actionSetting = jsYaml.load(fs.readFileSync(path.resolve(rootDir, 'action.yml'), 'utf8')) || {};
    const inputs = typeof actionSetting === 'object' && typeof actionSetting['inputs'] === 'object' ? actionSetting['inputs'] : {};
    const envs = Object.keys(inputs).filter(key => 'default' in inputs[key]).map(key => ({
        key: `INPUT_${key.replace(/ /g, '_').toUpperCase()}`,
        value: `${inputs[key].default}`,
    }));
    envs.forEach(env => {
        process.env[env.key] = env.value;
    });
    return envs;
};
const testEnv = (rootDir) => {
    const OLD_ENV = process.env;
    vitest.beforeEach(() => {
        vitest.vi.resetModules();
        process.env = { ...OLD_ENV };
        delete process.env.NODE_ENV;
        if (rootDir) {
            setActionEnv(rootDir);
        }
    });
    vitest.afterEach(() => {
        process.env = OLD_ENV;
    });
};
const testChildProcess = () => {
    vitest.afterEach(() => {
        global$1.mockChildProcess.stdout = 'stdout';
        global$1.mockChildProcess.stderr = '';
        global$1.mockChildProcess.error = null;
        global$1.mockChildProcess.code = 0;
    });
};
const setChildProcessParams = (params) => {
    if (typeof params.stdout === 'string' || typeof params.stdout === 'function') {
        global$1.mockChildProcess.stdout = params.stdout;
    }
    if (typeof params.stderr === 'string' || typeof params.stderr === 'function') {
        global$1.mockChildProcess.stderr = params.stderr;
    }
    if (params.error instanceof Error || typeof params.error === 'function') {
        global$1.mockChildProcess.error = params.error;
    }
    if (typeof params.code === 'number' || typeof params.code === 'function') {
        global$1.mockChildProcess.code = params.code;
    }
};
const testFs = (defaultExists = false) => {
    let existsData = [defaultExists];
    let callback = undefined;
    let count = 0;
    let stop = false;
    const spy = [];
    const setupMock = () => {
        if (stop) {
            return;
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        spy.push(vitest.vi.spyOn(fs, 'writeFileSync').mockImplementation(() => {
        }));
        spy.push(vitest.vi.spyOn(fs, 'mkdirSync').mockImplementation(() => undefined));
        spy.push(vitest.vi.spyOn(fs, 'existsSync').mockImplementation((path) => {
            if (typeof callback === 'function') {
                return callback(path);
            }
            // eslint-disable-next-line no-magic-numbers
            const result = count < existsData.length ? existsData[count] : existsData[existsData.length - 1];
            count++;
            return result;
        }));
    };
    const clearMock = () => {
        spy.forEach(spy => spy.mockRestore());
        spy.length = 0;
        callback = undefined;
        existsData = [defaultExists];
        // eslint-disable-next-line no-magic-numbers
        count = 0;
    };
    vitest.beforeEach(setupMock);
    vitest.afterEach(clearMock);
    return (flag) => {
        callback = undefined;
        stop = false;
        if (undefined === flag) {
            stop = true;
            clearMock();
        }
        else if (typeof flag === 'function') {
            callback = flag;
        }
        else if (typeof flag === 'boolean') {
            existsData = [flag];
        }
        else {
            existsData = flag;
        }
    };
};
const spyOnStdout = () => global$1.mockStdout.write;
const stdoutCalledWith = (spyOnMock, messages) => {
    vitest.expect(spyOnMock).toBeCalledTimes(messages.length);
    messages.forEach((message, index) => {
        vitest.expect(spyOnMock.mock.calls[index][0]).toBe(message + os.EOL);
    });
};
const stdoutContains = (spyOnMock, messages) => {
    vitest.expect(spyOnMock.mock.calls.map(value => value[0].trim())).toEqual(vitest.expect.arrayContaining(messages));
};
const stdoutNotContains = (spyOnMock, messages) => {
    vitest.expect(spyOnMock.mock.calls.map(value => value[0].trim())).toEqual(vitest.expect.not.arrayContaining(messages));
};
const spyOnExec = () => global$1.mockChildProcess.exec;
const spyOnSpawn = () => global$1.mockChildProcess.spawn;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const execCalledWith = (spyOnMock, messages) => {
    vitest.expect(spyOnMock).toBeCalledTimes(messages.length);
    messages.forEach((message, index) => {
        if (typeof message === 'string') {
            vitest.expect(spyOnMock.mock.calls[index][0]).toBe(message);
        }
        else {
            message.forEach((message, index2) => {
                if (typeof spyOnMock.mock.calls[index][index2] === 'object') {
                    vitest.expect(spyOnMock.mock.calls[index][index2]).toEqual(message);
                }
                else {
                    vitest.expect(spyOnMock.mock.calls[index][index2]).toBe(message);
                }
            });
        }
    });
};
const execContains = (spyOnMock, messages) => {
    vitest.expect(spyOnMock.mock.calls.map(value => value[0])).toEqual(vitest.expect.arrayContaining(messages));
};
const execNotContains = (spyOnMock, messages) => {
    vitest.expect(spyOnMock.mock.calls.map(value => value[0])).toEqual(vitest.expect.not.arrayContaining(messages));
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
const getLogStdout = (value, prefix = '') => prefix + JSON.stringify(value, null, '\t');
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
const testProperties = (object, checks) => {
    vitest.expect(typeof object).toBe('object');
    Object.keys(checks).forEach(key => {
        vitest.expect(object).toHaveProperty(key);
        if (typeof checks[key] === 'object') {
            vitest.expect(object[key]).toEqual(checks[key]);
        }
        else {
            vitest.expect(object[key]).toBe(checks[key]);
        }
    });
};
const getOctokit = (token) => github.getOctokit(token ?? 'test-token');

vitest.vi.mock('@actions/core');
const spyOnExportVariable = () => vitest.vi.spyOn(core__namespace, 'exportVariable').mockReturnValue();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const exportVariableCalledWith = (spyOnMock, pairs) => {
    vitest.expect(spyOnMock).toBeCalledTimes(pairs.length);
    pairs.forEach(({ name, val }, index) => {
        vitest.expect(spyOnMock.mock.calls[index][0]).toBe(name);
        vitest.expect(spyOnMock.mock.calls[index][1]).toEqual(val);
    });
};
const spyOnAddPath = () => vitest.vi.spyOn(core__namespace, 'addPath').mockReturnValue();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const addPathCalledWith = (spyOnMock, paths) => {
    vitest.expect(spyOnMock).toBeCalledTimes(paths.length);
    paths.forEach((path, index) => {
        vitest.expect(spyOnMock.mock.calls[index][0]).toBe(path);
    });
};
const spyOnSetOutput = () => vitest.vi.spyOn(core__namespace, 'setOutput').mockReturnValue();
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setOutputCalledWith = (spyOnMock, pairs) => {
    vitest.expect(spyOnMock).toBeCalledTimes(pairs.length);
    pairs.forEach(({ name, value }, index) => {
        vitest.expect(spyOnMock.mock.calls[index][0]).toBe(name);
        vitest.expect(spyOnMock.mock.calls[index][1]).toEqual(value);
    });
};

const setupGlobal = () => {
    global$1.mockStdout = {
        write: vitest.vi.fn(),
    };
    process.stdout.write = global$1.mockStdout.write;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const converter = (prefix = '') => (value) => process.stdout.write(prefix + JSON.stringify(value, null, '\t') + os.EOL);
    console.log = vitest.vi.fn(converter());
    console.info = vitest.vi.fn(converter('__info__'));
    console.error = vitest.vi.fn(converter('__error__'));
    console.warn = vitest.vi.fn(converter('__warning__'));
    global$1.mockChildProcess = {
        stdout: 'stdout',
        stderr: '',
        error: null,
        code: 0,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        exec: vitest.vi.fn((...args) => {
            const callback = args.length === 2 ? args[1] : args[2];
            callback(typeof global$1.mockChildProcess.error === 'function' ? global$1.mockChildProcess.error(args[0]) : global$1.mockChildProcess.error, typeof global$1.mockChildProcess.stdout === 'function' ? global$1.mockChildProcess.stdout(args[0]) : global$1.mockChildProcess.stdout, typeof global$1.mockChildProcess.stderr === 'function' ? global$1.mockChildProcess.stderr(args[0]) : global$1.mockChildProcess.stderr);
        }),
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        spawn: vitest.vi.fn((...args) => ({
            stdout: {
                on: (event, callback) => {
                    if (event === 'data') {
                        callback(typeof global$1.mockChildProcess.stdout === 'function' ? global$1.mockChildProcess.stdout(args[0]) : global$1.mockChildProcess.stdout);
                    }
                },
            },
            stderr: {
                on: (event, callback) => {
                    if (event === 'data') {
                        callback(typeof global$1.mockChildProcess.stderr === 'function' ? global$1.mockChildProcess.stderr(args[0]) : global$1.mockChildProcess.stderr);
                    }
                },
            },
            on: (event, callback) => {
                if (event === 'error') {
                    const error = typeof global$1.mockChildProcess.error === 'function' ? global$1.mockChildProcess.error(args[0]) : global$1.mockChildProcess.error;
                    if (error) {
                        callback(error);
                    }
                }
                else if (event === 'close') {
                    callback(typeof global$1.mockChildProcess.code === 'function' ? global$1.mockChildProcess.code(args[0]) : global$1.mockChildProcess.code);
                }
            },
        })),
    };
    vitest.vi.mock('child_process', async () => ({
        ...await vitest.vi.importActual('child_process'),
        exec: global$1.mockChildProcess.exec,
        spawn: global$1.mockChildProcess.spawn,
    }));
    process.env.GITHUB_ACTOR = 'octocat';
    process.env.GITHUB_PATH = '/home/runner/work/_temp/_runner_file_commands/add_path_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
    process.env.GITHUB_ENV = '/home/runner/work/_temp/_runner_file_commands/set_env_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
    process.env.GITHUB_STEP_SUMMARY = '/home/runner/work/_temp/_runner_file_commands/step_summary_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
    process.env.GITHUB_STATE = '/home/runner/work/_temp/_runner_file_commands/save_state_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
    process.env.GITHUB_OUTPUT = '/home/runner/work/_temp/_runner_file_commands/set_output_aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee';
};

exports.addPathCalledWith = addPathCalledWith;
exports.createResponse = createResponse;
exports.disableNetConnect = disableNetConnect;
exports.encodeContent = encodeContent;
exports.execCalledWith = execCalledWith;
exports.execContains = execContains;
exports.execNotContains = execNotContains;
exports.exportVariableCalledWith = exportVariableCalledWith;
exports.generateContext = generateContext;
exports.getApiFixture = getApiFixture;
exports.getConfigFixture = getConfigFixture;
exports.getContext = getContext;
exports.getLogStdout = getLogStdout;
exports.getOctokit = getOctokit;
exports.setActionEnv = setActionEnv;
exports.setChildProcessParams = setChildProcessParams;
exports.setOutputCalledWith = setOutputCalledWith;
exports.setupGlobal = setupGlobal;
exports.spyOnAddPath = spyOnAddPath;
exports.spyOnExec = spyOnExec;
exports.spyOnExportVariable = spyOnExportVariable;
exports.spyOnSetOutput = spyOnSetOutput;
exports.spyOnSpawn = spyOnSpawn;
exports.spyOnStdout = spyOnStdout;
exports.stdoutCalledWith = stdoutCalledWith;
exports.stdoutContains = stdoutContains;
exports.stdoutNotContains = stdoutNotContains;
exports.testChildProcess = testChildProcess;
exports.testEnv = testEnv;
exports.testFs = testFs;
exports.testProperties = testProperties;
